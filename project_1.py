# -*- coding: utf-8 -*-
"""Project 1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-6btvbeJWmSHblVSIM5J4I6F0A9Dw4dY
"""

# 1. Install RDKit (Crucial for translating chemistry to code)
!pip install rdkit

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from rdkit import Chem
from rdkit.Chem import Descriptors

# 2. Load the Dataset from DeepChem (Amazon S3)
# p_np: 1 = Permeable (Passes), 0 = Non-Permeable (Fails)
url = "https://deepchemdata.s3-us-west-1.amazonaws.com/datasets/BBBP.csv"
dataset = pd.read_csv(url)

# 3. Clean the Data
# We only want the Structure (smiles) and the Target (p_np)
dataset = dataset[['smiles', 'p_np']]
dataset.columns = ['SMILES', 'Label'] # Rename for clarity

# Remove any rows where the SMILES string is broken/empty
dataset = dataset.dropna()

print(f"‚úÖ Success! Loaded {len(dataset)} compounds.")
print("Class Balance (1=Pass, 0=Fail):")
print(dataset['Label'].value_counts())

dataset['Label'].value_counts()

from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, confusion_matrix, classification_report
from rdkit import Chem
from rdkit.Chem import Descriptors

# Function to calculate molecular descriptors from a SMILES string
def calculate_descriptors_from_smiles(smiles):
    mol = Chem.MolFromSmiles(smiles)
    if mol is None:
        # Return a Series of NaN for invalid SMILES strings
        return pd.Series({
            'MolLogP': np.nan,
            'MolWt': np.nan,
            'NumHDonors': np.nan,
            'TPSA': np.nan
        })
    return pd.Series({
        'MolLogP': Descriptors.MolLogP(mol),
        'MolWt': Descriptors.MolWt(mol),
        'NumHDonors': Descriptors.NumHDonors(mol),
        'TPSA': Descriptors.TPSA(mol)
    })

# Apply the function to the 'SMILES' column of the dataset
# This creates a DataFrame of descriptors, one row per original molecule
molecular_descriptors = dataset['SMILES'].apply(calculate_descriptors_from_smiles)

# Drop rows where descriptor calculation failed (e.g., invalid SMILES)
molecular_descriptors = molecular_descriptors.dropna()

# Align the original dataset with the successfully calculated descriptors
# This ensures that only molecules with valid SMILES and calculated descriptors are kept
final_data = dataset.loc[molecular_descriptors.index].copy()
final_data = final_data.join(molecular_descriptors)

# 1. Prepare X (Features) and y (Target)
X = final_data[['MolLogP', 'MolWt', 'NumHDonors', 'TPSA']]
y = final_data['Label']

# 2. Split with Stratification (Crucial for imbalanced data)
# This ensures the Test set also has exactly ~24% "Fail" cases.
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42, stratify=y)

# 3. Train the Random Forest
# n_estimators=100 means we create 100 decision trees and let them vote
model = RandomForestClassifier(n_estimators=100, random_state=42)
model.fit(X_train, y_train)

# 4. Evaluate
y_pred = model.predict(X_test)
acc = accuracy_score(y_test, y_pred)

print(f"‚úÖ Model Accuracy: {acc:.2%}")
print("\nConfusion Matrix (The Truth Table):")
print(confusion_matrix(y_test, y_pred))
print("\nClassification Report:")
print(classification_report(y_test, y_pred))

# 1. Define the Candidates (SMILES strings)
candidates = {
    "Generic Curcumin": "COC1=C(O)C=CC(=C1)/C=C/C(=O)CC(=O)/C=C/C2=CC(=C(O)C(OC)=C2)",
    "Tetrahydrocurcumin (Metabolite)": "COC1=C(O)C=CC(=C1)CCC(=O)CC(=O)CCC2=CC(=C(O)C(OC)=C2)",
    "Curcumin Difluoride (Fluorinated)": "COC1=C(O)C=CC(=C1)/C=C/C(=O)CF(F)C(=O)/C=C/C2=CC(=C(O)C(OC)=C2)",
    "Exalure (Novel Analog)": "CC(=O)OC1=C(OC)C=C(C=C1)/C=C/C(=O)CC(=O)/C=C/C2=CC(=C(OC(=O)C)C(OC)=C2)"
}

print("üß™ Screening Candidates for Brain Permeability...\n")

# 2. Loop through each candidate and predict
for name, smiles in candidates.items():
    # Calculate the 4 Descriptors
    # We use the same function 'calculate_descriptors_from_smiles' from before
    feats = calculate_descriptors_from_smiles(smiles)

    # Reshape for the model (it expects a list of lists)
    # The columns MUST be in the same order: [MolLogP, MolWt, NumHDonors, TPSA]
    feats_df = pd.DataFrame([feats], columns=['MolLogP', 'MolWt', 'NumHDonors', 'TPSA'])

    # Predict Class (0 or 1)
    prediction = model.predict(feats_df)[0]
    # Predict Probability (How confident is the model?)
    probability = model.predict_proba(feats_df)[0][1] # Probability of Class 1

    # Print Results
    result = "‚úÖ PASS (Enters Brain)" if prediction == 1 else "‚ùå FAIL (Blocked)"
    print(f"Name: {name}")
    print(f"Result: {result}")
    print(f"Confidence: {probability:.2%}")
    print(f"Properties: LogP={feats[0]:.2f}, Weight={feats[1]:.0f}, Donors={feats[2]}, TPSA={feats[3]:.0f}")
    print("-" * 30)

import ipywidgets as widgets
from IPython.display import display
from rdkit import Chem
from rdkit.Chem import Descriptors
import pandas as pd
import numpy as np

# --- 1. RE-DEFINE THE TRANSLATOR ---
def get_mol_descriptors(smiles):
    try:
        mol = Chem.MolFromSmiles(smiles)
        if mol:
            logp = Descriptors.MolLogP(mol)
            mw = Descriptors.MolWt(mol)
            h_donors = Descriptors.NumHDonors(mol)
            tpsa = Descriptors.TPSA(mol)
            return [logp, mw, h_donors, tpsa]
        else:
            return [None, None, None, None]
    except:
        return [None, None, None, None]

# --- 2. DASHBOARD LOGIC ---
def display_result(pred, prob, feats):
    color = "green" if pred == 1 else "red"
    status = "PASSED (Brain Permeable)" if pred == 1 else "FAILED (Blocked)"

    html_str = f"""
    <div style="border: 2px solid {color}; padding: 10px; border-radius: 5px;">
        <h3 style="color: {color};">{status}</h3>
        <p><b>Confidence:</b> {prob:.1%}</p>
        <hr>
        <h4>Physicochemical Profile:</h4>
        <ul>
            <li><b>Lipophilicity (LogP):</b> {feats[0]:.2f} (Target: 2.0 - 5.0)</li>
            <li><b>Molecular Weight:</b> {feats[1]:.0f} (Target: < 450)</li>
            <li><b>H-Bond Donors:</b> {feats[2]} (Target: < 3)</li>
            <li><b>Polar Surface Area (TPSA):</b> {feats[3]:.0f} (Target: < 90)</li>
        </ul>
    </div>
    """
    display(widgets.HTML(html_str))

def on_button_clicked(b):
    with output:
        output.clear_output()
        # Clean the input to prevent errors
        smiles = smiles_input.value.strip().replace('"', '').replace("'", "")

        if not smiles:
            print("‚ö†Ô∏è Please enter a SMILES string.")
            return

        feats = get_mol_descriptors(smiles)

        # Check for invalid chemistry (NaN)
        if feats[0] is None:
            print(f"‚ùå Chemistry Error: Could not analyze structure.\nCheck your SMILES string for typos (e.g., F with too many bonds).")
            return

        feats_df = pd.DataFrame([feats], columns=['MolLogP', 'MolWt', 'NumHDonors', 'TPSA'])

        try:
            # We assume 'model' exists from previous steps.
            # If not, this try/except catches it.
            prediction = model.predict(feats_df)[0]
            prob = model.predict_proba(feats_df)[0][1]
            display_result(prediction, prob, feats)
        except NameError:
            print("‚ùå Critical Error: The 'model' is missing. Please re-run the Training Step (Phase 3) above.")

# --- 3. LAUNCH UI ---
title = widgets.HTML("<h2>üß† The Neuro-Therapeutic Designer</h2>")

# I fixed the SMILES here to be chemically valid "Curcumin Difluoride"
# Note the C(F)(F) in the middle
safe_smiles = "COC1=C(O)C=CC(=C1)C=CC(=O)C(F)(F)C(=O)C=CC2=CC(=C(O)C(OC)=C2)"

smiles_input = widgets.Text(
    value=safe_smiles,
    placeholder='Type a SMILES string here...',
    description='SMILES:',
    layout=widgets.Layout(width='80%')
)

button = widgets.Button(
    description='Analyze Molecule',
    button_style='success',
    icon='flask'
)

output = widgets.Output()
button.on_click(on_button_clicked)

display(title, smiles_input, button, output)

def on_button_clicked(b):
    with output:
        output.clear_output()
        smiles = smiles_input.value.strip().replace('"', '').replace("'", "")

        if not smiles: return
        feats = get_mol_descriptors(smiles)
        if feats[0] is None:
            print("‚ùå Invalid Chemistry"); return

        feats_df = pd.DataFrame([feats], columns=['MolLogP', 'MolWt', 'NumHDonors', 'TPSA'])

        # 1. Ask the AI
        prediction = model.predict(feats_df)[0]
        prob = model.predict_proba(feats_df)[0][1]

        # 2. Apply Engineering Constraints (The "Sanity Check")
        molecular_weight = feats[1]

        if prediction == 1 and molecular_weight > 500:
            prediction = 0 # Force a Fail
            prob = 0.0 # Reset confidence
            print("‚ö†Ô∏è AI Override: Molecule is too heavy (>500 Da) despite good oiliness.")

        display_result(prediction, prob, feats)

button.on_click(on_button_clicked)
print("‚úÖ Safety Protocols Installed.")